.panel.panel-default
  .panel-body
    - if project.cycle.try(:days)
      .progress
        %div{"aria-valuemax" => "#{project.cycle.days}", "aria-valuemin" => "1", "aria-valuenow" => "#{project.actual_day_of_sprint}", :class => "progress-bar #{progress_bar_color(project.days_percentage)}", :role => "progressbar", :style => "min-width: 2em; width: #{project.days_percentage}%;"}
    - if project.started?
      Sprint
      = project.sprint
    - elsif project.countdown < 0
      = t("release_date_not_defined_yet")
    - else
      = project.countdown
      days left to start

  - if project.started?
    .panel-body
      - if project.tasks.size.nonzero?
        .progress.visible-xs
          .progress-bar.progress-bar-info{ style: "width: #{percentage_from_value_and_total(project.tasks.release.size, project.tasks.size)}%;" }
          .progress-bar.progress-bar-danger{ style: "width: #{percentage_from_value_and_total(project.tasks.in_sprint.size, project.tasks.size)}%;" }
          .progress-bar.progress-bar-warning{ style: "width: #{percentage_from_value_and_total(project.tasks.in_progress.size, project.tasks.size)}%;" }
          .progress-bar.progress-bar-success{ style: "width: #{percentage_from_value_and_total(project.tasks.done.size, project.tasks.size)}%;" }
      %strong
        = link_to project_tasks_path(project, "filterrific[reset_filterrific]" => true) do
          = pluralize project.tasks.size, 'task'
      .hidden-xs
        - if project.tasks.size.nonzero?
          = pie_chart Status.all.order(:id).map { |status| [t("projects.tasks.#{status.translation_code}"), project.tasks.where(status: status).count] }, height: "180px", library: { chartArea: { height: '100%', width: '92%' }, legend: { position: 'right', alignment: 'center' }, colors: [ '#607d8b', '#2196f3', '#f44336', '#ffc107', '#43a047' ] }

    .panel-body.hidden-xs
      %strong
        Workload

    .list-group.hidden-xs
      - if project.sprints.size.nonzero?
        .list-group-item
          Burn up
          - total_workload = 0
          - last_sprint    = project.sprints.last
          - burn_up_data   = project.tasks.unscoped.done.group_by_period(:day, :updated_at).where('updated_at >= ?', last_sprint.created_at).order('max(updated_at)').sum(:workload)
          - if burn_up_data.empty?
            - burn_up_data = { last_sprint.created_at => 0 }
          - burn_up_data = burn_up_data.transform_keys { |key| key.strftime('%B %d') }
          = area_chart burn_up_data.each { |key, value| burn_up_data[key] = total_workload += value }, discrete: true, library: { chartArea: { width: '80%', height: '90%' }, hAxis: { textPosition: 'none' }, pointSize: 8 }

      .list-group-item
        = badge(project.tasks.where('status_id = ? or status_id = ?', Status.in_progress.first, Status.sprint.first).sum(:workload))
        in sprint
      .list-group-item
        = badge(project.tasks.done.sum(:workload))
        done
      .list-group-item
        = badge(project.tasks.average(:standard_deviation).try(:round, 2))
        average standard deviation
